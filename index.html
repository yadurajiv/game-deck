<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GameDeck - Ideation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;500;600;700&display=swap');
        
        body { font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Crimson Text', serif; }
        
        /* Card Animations */
        .card-container { perspective: 1000px; }
        .card-enter { animation: cardEnter 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        .card-discard-left { animation: discardLeft 0.3s ease-in forwards; }
        .card-keep-right { animation: keepRight 0.3s ease-in forwards; }
        .card-burn { animation: burnCard 0.4s ease-in forwards; }
        .card-reshuffle-enter { animation: reshuffleEnter 0.5s ease-out forwards; }

        @keyframes cardEnter { from { opacity: 0; transform: translateY(40px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
        @keyframes discardLeft { to { opacity: 0; transform: translateX(-120%) rotate(-20deg); } }
        @keyframes keepRight { to { opacity: 0; transform: translateX(120%) rotate(20deg); } }
        @keyframes burnCard { 0% { transform: scale(1); filter: grayscale(0%); } 50% { transform: scale(0.9); filter: grayscale(100%) brightness(0.5); } 100% { transform: scale(0) translateY(50px); opacity: 0; } }
        @keyframes reshuffleEnter { 0% { transform: translateY(-50px) scale(0.9); opacity: 0; } 50% { transform: translateY(10px) scale(1.02); opacity: 1; } 100% { transform: translateY(0) scale(1); opacity: 1; } }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-900 h-[100dvh] flex flex-col md:flex-row overflow-hidden">

    <!-- Sidebar -->
    <div class="bg-slate-900 text-slate-300 w-full md:w-64 flex-shrink-0 flex flex-col border-b md:border-r border-slate-700 z-50 relative">
        <div class="p-4 flex justify-between items-center h-16 bg-slate-900 z-50 relative">
            <div class="flex items-center space-x-2">
                <i data-lucide="layers" class="text-indigo-400"></i>
                <h1 id="app-title" class="font-bold text-white tracking-wide">GameDeck</h1>
            </div>
            <div class="flex items-center gap-3">
                <span id="app-version" class="text-xs bg-indigo-900 text-indigo-300 px-2 py-0.5 rounded-full">v4.0.1</span>
                <button onclick="app.toggleMobileMenu()" class="md:hidden text-slate-400 hover:text-white transition-colors p-1">
                    <i data-lucide="menu" id="menu-icon" class="w-6 h-6"></i>
                </button>
            </div>
        </div>

        <div id="sidebar-content" class="hidden md:flex flex-col flex-1 bg-slate-900/95 backdrop-blur-md md:backdrop-blur-none md:bg-transparent absolute md:relative top-16 md:top-0 left-0 w-full md:w-auto h-[calc(100dvh-4rem)] md:h-auto z-40 md:z-auto border-b md:border-0 border-slate-700 md:shadow-none overflow-y-auto md:overflow-visible transition-all">
            <nav class="flex flex-col p-2 space-y-1">
                <button onclick="app.setView('draw')" id="nav-draw" class="flex items-center px-3 py-3 md:py-2 rounded-lg text-sm font-medium transition-colors hover:bg-slate-800 w-full text-left">
                    <i data-lucide="sparkles" class="mr-3 md:mr-2 w-5 h-5 md:w-4 md:h-4"></i> Draw
                </button>
                <button onclick="app.setView('saved')" id="nav-saved" class="flex items-center px-3 py-3 md:py-2 rounded-lg text-sm font-medium transition-colors hover:bg-slate-800 w-full text-left">
                    <i data-lucide="save" class="mr-3 md:mr-2 w-5 h-5 md:w-4 md:h-4"></i> Saved Hand 
                    <span id="saved-count" class="ml-auto bg-slate-800 px-2 py-0.5 rounded-full text-xs">0</span>
                </button>
                <button onclick="app.setView('gallery')" id="nav-gallery" class="flex items-center px-3 py-3 md:py-2 rounded-lg text-sm font-medium transition-colors hover:bg-slate-800 w-full text-left">
                    <i data-lucide="grid" class="mr-3 md:mr-2 w-5 h-5 md:w-4 md:h-4"></i> Gallery
                </button>
            </nav>

            <!-- Dynamic Deck List Container -->
            <div class="mt-auto p-4 border-t border-slate-800 overflow-y-auto no-scrollbar pb-8 md:pb-4">
                <h3 class="text-xs font-bold uppercase text-slate-500 mb-3 tracking-wider">Active Decks</h3>
                <div id="deck-toggle-list" class="space-y-2">
                    <!-- Decks injected via JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-1 relative overflow-y-auto bg-slate-100 p-2 md:p-8" id="main-content">
        <!-- Views injected here -->
    </main>

    <!-- Templates -->
    <template id="tpl-draw">
        <div class="min-h-full flex flex-col items-center justify-center max-w-lg mx-auto w-full py-2 md:py-4">
            <div class="mb-2 md:mb-6 text-center">
                <span id="deck-label" class="text-xs font-bold uppercase tracking-widest text-slate-400">Combined Deck</span>
                <p id="card-counter" class="text-slate-500 text-sm mt-0.5 md:mt-1">Card 1 of 50</p>
            </div>
            <div id="card-wrapper" class="card-container w-72 h-96 relative touch-none select-none shadow-xl rounded-2xl flex-shrink-0 bg-slate-200"></div>
            <p class="md:hidden text-xs text-indigo-400 mt-4 md:mt-6 flex items-center justify-center gap-4 opacity-70">
                <span>‚Üê Discard</span><span>‚Ä¢</span><span>Keep ‚Üí</span>
            </p>
            <div class="flex gap-3 md:gap-4 mt-4 md:mt-8 w-full max-w-xs px-2 md:px-0">
                <button onclick="app.discard()" class="flex-1 flex flex-col items-center justify-center p-3 md:p-4 bg-white border border-slate-200 rounded-xl shadow-sm hover:shadow-md hover:bg-slate-50 transition-all group active:scale-95">
                    <i data-lucide="trash-2" class="text-slate-400 group-hover:text-red-500 mb-1 w-5 h-5"></i>
                    <span class="text-xs font-bold text-slate-500">Discard</span>
                </button>
                <button onclick="app.burn()" class="w-12 flex flex-col items-center justify-center p-3 md:p-4 bg-slate-200 rounded-xl shadow-sm hover:bg-slate-300 transition-all group active:scale-95" title="Burn">
                    <i data-lucide="flame" class="text-slate-500 group-hover:text-orange-500 mb-1 w-5 h-5"></i>
                </button>
                <button onclick="app.keep()" class="flex-1 flex flex-col items-center justify-center p-3 md:p-4 bg-indigo-600 rounded-xl shadow-lg shadow-indigo-200 hover:bg-indigo-500 hover:shadow-indigo-300 transition-all transform hover:-translate-y-1 active:scale-95">
                    <i data-lucide="save" class="text-white mb-1 w-5 h-5"></i>
                    <span class="text-xs font-bold text-white">Keep</span>
                </button>
            </div>
            <button onclick="app.reshuffle(true)" class="mt-4 md:mt-8 flex items-center text-slate-400 hover:text-indigo-600 text-xs font-bold uppercase tracking-widest transition-colors p-2 mb-safe">
                <i data-lucide="refresh-cw" class="mr-2 w-3 h-3"></i> Reshuffle Deck
            </button>
        </div>
    </template>

    <template id="tpl-saved">
        <div class="max-w-5xl mx-auto w-full pt-4 px-2 md:px-0">
            <div class="flex items-center justify-between mb-8">
                <h2 class="text-2xl font-bold text-slate-800">Your Hand</h2>
                <button onclick="app.clearSaved()" class="text-red-500 text-sm font-medium hover:text-red-700 flex items-center bg-white px-3 py-1.5 rounded-lg border border-red-100 shadow-sm">
                    <i data-lucide="trash-2" class="mr-1 w-4 h-4"></i> Clear All
                </button>
            </div>
            <div id="saved-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 pb-20"></div>
            <div id="empty-state" class="hidden text-center py-20 border-2 border-dashed border-slate-300 rounded-xl">
                <div class="text-4xl mb-4">ü´•</div>
                <p class="text-slate-500 font-medium">No cards saved yet.</p>
                <button onclick="app.setView('draw')" class="text-indigo-600 font-bold text-sm mt-2 hover:underline">Go draw some!</button>
            </div>
        </div>
    </template>

    <template id="tpl-gallery">
        <div class="max-w-6xl mx-auto pb-10 w-full pt-4 px-2 md:px-0">
            <div class="mb-8">
                <h2 class="text-2xl font-bold text-slate-800">Full Deck Gallery</h2>
                <p class="text-sm text-slate-500 mt-1">Showing all cards from active decks. <span class="text-orange-600 font-medium">Burned cards</span> are dimmed; tap to restore.</p>
            </div>
            <div id="gallery-content"></div>
        </div>
    </template>

    <script>
        // ==========================================
        // APP LOGIC WITH JSON FETCHING
        // ==========================================

        let APP_CONFIG = null; // Will be loaded from config.json

        const app = {
            state: {
                activeDeckIds: {}, 
                currentDeck: [],
                drawIndex: 0,
                keptCards: [],
                burnedCardIds: [],
                view: 'draw',
                animating: false,
                mobileMenuOpen: false,
                loading: true,
                error: null
            },

            async init() {
                try {
                    // 1. Fetch Config
                    const configRes = await fetch('config.json');
                    if (!configRes.ok) throw new Error('Could not load config.json');
                    APP_CONFIG = await configRes.json();

                    // Set titles
                    document.getElementById('app-title').innerText = APP_CONFIG.title;
                    document.getElementById('app-version').innerText = APP_CONFIG.version;

                    // 2. Fetch Decks
                    await this.loadDecks();

                    // 3. Render UI
                    this.renderDeckToggles();
                    
                    // 4. Initialize State
                    const loaded = this.loadState();
                    if (!loaded || Object.keys(this.state.activeDeckIds).length === 0) {
                        // Default: activate first enabled deck found
                        const firstDeck = APP_CONFIG.decks.find(d => d.enabled);
                        if (firstDeck) {
                            this.state.activeDeckIds = { [firstDeck.id]: true };
                            this.shuffleDecks();
                        }
                    } else {
                        // Clean burned cards
                        if (this.state.burnedCardIds.length > 0) {
                            this.state.currentDeck = this.state.currentDeck.filter(c => !this.state.burnedCardIds.includes(c.id));
                            if(this.state.currentDeck.length === 0) this.shuffleDecks();
                        }
                    }

                    this.state.loading = false;
                    this.render();
                    this.setupGestures();

                } catch (e) {
                    console.error("Init failed", e);
                    this.state.error = "Failed to load game data. Ensure you are running this on a local server (e.g., Live Server), not directly from file://.";
                    this.render();
                }
            },

            async loadDecks() {
                // Iterate through decks in config and fetch their data
                // We will attach the loaded 'cards' array directly to the config object in memory
                const fetchPromises = APP_CONFIG.decks.map(async (deck) => {
                    if (!deck.file) return; 
                    try {
                        const res = await fetch(deck.file);
                        if(res.ok) {
                            const data = await res.json();
                            deck.cards = data.cards; // Attach cards to config
                            deck.themes = data.themes;
                            deck.description = data.description;
                        } else {
                            console.warn(`Failed to load deck file: ${deck.file}`);
                            deck.cards = []; // Empty fallback
                        }
                    } catch (err) {
                        console.warn(`Error fetching ${deck.file}`, err);
                        deck.cards = [];
                    }
                });

                await Promise.all(fetchPromises);
            },

            // --- Helper: Generate IDs for Cards on Runtime ---
            flattenDeckData() {
                if (!APP_CONFIG) return [];
                let allCards = [];
                APP_CONFIG.decks.forEach(deck => {
                    if (deck.cards && deck.cards.length > 0) {
                        deck.cards.forEach(card => {
                            const id = `${deck.id}-${card.suit}-${card.rank}`;
                            allCards.push({ ...card, id: id, _deckId: deck.id });
                        });
                    }
                });
                return allCards;
            },

            getCardMap() {
                const map = {};
                this.flattenDeckData().forEach(c => map[c.id] = c);
                return map;
            },

            // --- Persistence ---
            saveState() {
                try {
                    const stateToSave = {
                        activeDeckIds: this.state.activeDeckIds,
                        currentDeckIds: this.state.currentDeck.map(c => c.id),
                        drawIndex: this.state.drawIndex,
                        keptCardIds: this.state.keptCards.map(c => c.id),
                        burnedCardIds: this.state.burnedCardIds
                    };
                    localStorage.setItem('gamedeck_state_v5', JSON.stringify(stateToSave));
                } catch (e) { console.error("Save failed", e); }
            },

            loadState() {
                const json = localStorage.getItem('gamedeck_state_v5');
                if(!json) return false;
                
                try {
                    const saved = JSON.parse(json);
                    const cardMap = this.getCardMap(); // Now relies on loaded config

                    this.state.activeDeckIds = saved.activeDeckIds || {};
                    this.state.drawIndex = saved.drawIndex || 0;
                    this.state.burnedCardIds = saved.burnedCardIds || [];
                    
                    if (saved.currentDeckIds && saved.currentDeckIds.length > 0) {
                        this.state.currentDeck = saved.currentDeckIds.map(id => cardMap[id]).filter(Boolean);
                    }
                    
                    if (saved.keptCardIds) {
                        this.state.keptCards = saved.keptCardIds.map(id => cardMap[id]).filter(Boolean);
                    }
                    return true;
                } catch(e) { console.error("Load failed", e); return false; }
            },

            // --- Core Logic ---
            toggleMobileMenu() {
                this.state.mobileMenuOpen = !this.state.mobileMenuOpen;
                this.render();
            },

            shuffleDecks() {
                let combined = [];
                const cardMap = this.getCardMap();

                Object.keys(this.state.activeDeckIds).forEach(deckId => {
                    if (this.state.activeDeckIds[deckId]) {
                        const deckCards = Object.values(cardMap).filter(c => c._deckId === deckId);
                        combined = [...combined, ...deckCards];
                    }
                });

                if(combined.length === 0) {
                    // Fallback to first enabled deck
                    const firstDeck = APP_CONFIG.decks.find(d => d.enabled);
                    if(firstDeck) {
                        this.state.activeDeckIds[firstDeck.id] = true;
                        combined = Object.values(cardMap).filter(c => c._deckId === firstDeck.id);
                    }
                }

                combined = combined.filter(c => !this.state.burnedCardIds.includes(c.id));

                if (combined.length === 0) {
                    this.state.burnedCardIds = [];
                     Object.keys(this.state.activeDeckIds).forEach(deckId => {
                         if (this.state.activeDeckIds[deckId]) {
                            const deckCards = Object.values(cardMap).filter(c => c._deckId === deckId);
                            combined = [...combined, ...deckCards];
                        }
                    });
                }

                for (let i = combined.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [combined[i], combined[j]] = [combined[j], combined[i]];
                }

                this.state.currentDeck = combined;
                this.state.drawIndex = 0;
                this.saveState();
            },

            toggleDeck(id) {
                const newState = !this.state.activeDeckIds[id];
                const newActiveIds = { ...this.state.activeDeckIds, [id]: newState };
                
                if (!Object.values(newActiveIds).some(Boolean)) return;

                this.state.activeDeckIds = newActiveIds;
                this.shuffleDecks();
                this.render();
            },

            setView(viewName) {
                this.state.view = viewName;
                this.state.mobileMenuOpen = false;
                this.render();
            },

            // --- Action Logic ---
            discard() {
                if (this.state.animating) return;
                const el = document.getElementById('card-wrapper')?.firstElementChild;
                if (el) {
                    el.classList.add('card-discard-left');
                    this.animateAdvance();
                }
            },
            keep() {
                if (this.state.animating) return;
                const el = document.getElementById('card-wrapper')?.firstElementChild;
                const card = this.state.currentDeck[this.state.drawIndex];
                if (el && card) {
                    el.classList.add('card-keep-right');
                    if (!this.state.keptCards.find(c => c.id === card.id)) {
                        this.state.keptCards.push(card);
                        this.saveState();
                    }
                    this.animateAdvance();
                }
            },
            burn() {
                if (this.state.animating) return;
                const el = document.getElementById('card-wrapper')?.firstElementChild;
                const card = this.state.currentDeck[this.state.drawIndex];
                if (el && card) {
                    el.classList.add('card-burn');
                    if (!this.state.burnedCardIds.includes(card.id)) {
                        this.state.burnedCardIds.push(card.id);
                        this.saveState();
                    }
                    this.animateAdvance(400);
                }
            },
            reshuffle(manual = false) {
                if (this.state.animating) return;
                const el = document.getElementById('card-wrapper')?.firstElementChild;
                if (el) {
                    el.style.transition = 'all 0.2s ease-in';
                    el.style.opacity = '0';
                    el.style.transform = 'scale(0.9)';
                }
                this.state.animating = true;
                setTimeout(() => {
                    this.shuffleDecks();
                    this.state.animating = false;
                    this.render(true);
                }, 250);
            },
            animateAdvance(delay = 300) {
                this.state.animating = true;
                setTimeout(() => {
                    this.advanceDeck();
                    this.state.animating = false;
                    this.render();
                }, delay);
            },
            advanceDeck() {
                if (this.state.drawIndex >= this.state.currentDeck.length - 1) {
                    this.shuffleDecks();
                    this.render(true);
                } else {
                    this.state.drawIndex++;
                    this.saveState();
                }
            },
            restoreBurned(id) {
                this.state.burnedCardIds = this.state.burnedCardIds.filter(bid => bid !== id);
                this.saveState();
                this.render();
            },
            clearSaved() {
                this.state.keptCards = [];
                this.saveState();
                this.render();
            },
            removeSaved(id) {
                this.state.keptCards = this.state.keptCards.filter(c => c.id !== id);
                this.saveState();
                this.render();
            },

            // --- Display Helpers ---
            getDeckConfig(deckId) {
                if (!APP_CONFIG) return {};
                return APP_CONFIG.decks.find(d => d.id === deckId) || {};
            },
            
            getSuitConfig(suitKey) {
                if (!APP_CONFIG) return { icon: 'circle', color: 'slate' };
                return APP_CONFIG.suits[suitKey] || { label: suitKey, icon: 'circle', color: 'slate' };
            },

            // --- HTML Generators ---
            renderDeckToggles() {
                const container = document.getElementById('deck-toggle-list');
                if(!container || !APP_CONFIG) return;
                
                container.innerHTML = APP_CONFIG.decks.map(deck => `
                    <button onclick="app.toggleDeck('${deck.id}')" id="btn-deck-${deck.id}" class="w-full flex items-center justify-between p-3 md:p-2 rounded border text-sm border-slate-700 text-slate-500 transition-colors">
                        <span>${deck.name}</span>
                        <div class="indicator w-2 h-2 rounded-full bg-indigo-500 hidden"></div>
                    </button>
                `).join('');
            },

            renderCardHTML(card, animationClass = '') {
                const deckConfig = this.getDeckConfig(card._deckId);
                const suitConfig = this.getSuitConfig(card.suit);
                const theme = deckConfig.themes?.[card.suit] || "";
                
                const isRed = suitConfig.color === 'red';
                const textColor = isRed ? 'text-red-600' : 'text-slate-800';
                const borderColor = isRed ? 'border-red-200' : 'border-slate-200';
                const bgGradient = isRed ? 'from-red-50 to-white' : 'from-slate-50 to-white';
                
                return `
                <div class="w-full h-full rounded-2xl shadow-2xl border-4 ${borderColor} bg-gradient-to-br ${bgGradient} flex flex-col p-4 relative overflow-hidden select-none bg-white ${animationClass}">
                    <div class="absolute top-0 left-0 right-0 flex justify-center pt-2">
                        <span class="text-[9px] font-bold uppercase tracking-widest px-2 py-0.5 rounded-full bg-black/5 text-black/40">
                            ${deckConfig.name || 'Unknown Deck'}
                        </span>
                    </div>
                    <div class="absolute top-4 left-4 flex flex-col items-center leading-none ${textColor}">
                        <span class="text-3xl font-bold font-serif">${card.rank}</span>
                        <i data-lucide="${suitConfig.icon}" class="w-4 h-4 fill-current"></i>
                    </div>
                    <div class="absolute bottom-4 right-4 flex flex-col items-center leading-none ${textColor} transform rotate-180">
                        <span class="text-3xl font-bold font-serif">${card.rank}</span>
                        <i data-lucide="${suitConfig.icon}" class="w-4 h-4 fill-current"></i>
                    </div>
                    <div class="flex-1 flex flex-col items-center justify-center text-center mt-6 z-10">
                        <div class="text-6xl mb-2 drop-shadow-sm filter">${card.visual}</div>
                        <div class="text-[10px] uppercase font-bold tracking-widest opacity-60 mb-1 ${textColor}">${theme}</div>
                        <h2 class="text-xl font-bold uppercase tracking-tight mb-1 ${textColor}">${card.title}</h2>
                        <div class="w-12 h-0.5 bg-black/10 mb-3"></div>
                        <p class="text-sm font-medium text-slate-600 mb-2 px-2 italic leading-relaxed">"${card.concept}"</p>
                        <div class="mt-auto mb-16 bg-white/60 backdrop-blur-sm rounded-lg p-2 text-xs text-slate-500 border border-black/5 w-full">
                            <span class="font-bold block mb-0.5 text-slate-400 uppercase text-[9px]">Examples</span>
                            <span class="text-slate-700 font-medium">${card.example}</span>
                        </div>
                    </div>
                </div>`;
            },

            render(isReshuffle = false) {
                const content = document.getElementById('main-content');
                const sidebar = document.getElementById('sidebar-content');

                // Error State
                if (this.state.error) {
                    content.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center p-8">
                        <i data-lucide="alert-triangle" class="w-12 h-12 text-red-500 mb-4"></i>
                        <h2 class="text-xl font-bold text-slate-800 mb-2">Setup Required</h2>
                        <p class="text-slate-600 max-w-md">${this.state.error}</p>
                    </div>`;
                    lucide.createIcons();
                    return;
                }

                // Loading State
                if (this.state.loading) {
                    content.innerHTML = `<div class="flex items-center justify-center h-full"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div></div>`;
                    return;
                }
                
                // Sidebar & Mobile Menu State
                if (this.state.mobileMenuOpen) {
                    sidebar.classList.remove('hidden');
                    document.getElementById('menu-icon').setAttribute('data-lucide', 'x');
                } else {
                    sidebar.classList.add('hidden');
                    document.getElementById('menu-icon').setAttribute('data-lucide', 'menu');
                }

                // Navbar Active State
                document.querySelectorAll('nav button').forEach(el => el.classList.remove('bg-indigo-600', 'text-white'));
                const activeNav = document.getElementById(`nav-${this.state.view}`);
                if(activeNav) activeNav.classList.add('bg-indigo-600', 'text-white');

                // Update Deck Toggle Buttons
                APP_CONFIG.decks.forEach(deck => {
                    const btn = document.getElementById(`btn-deck-${deck.id}`);
                    if (!btn) return;
                    if (this.state.activeDeckIds[deck.id]) {
                        btn.classList.add('bg-slate-800', 'border-indigo-500/50', 'text-indigo-300');
                        btn.querySelector('.indicator').classList.remove('hidden');
                    } else {
                        btn.classList.remove('bg-slate-800', 'border-indigo-500/50', 'text-indigo-300');
                        btn.querySelector('.indicator').classList.add('hidden');
                    }
                });

                document.getElementById('saved-count').innerText = this.state.keptCards.length;

                // Render Views
                if (this.state.view === 'draw') {
                    const tpl = document.getElementById('tpl-draw');
                    if (content.innerHTML === '') content.innerHTML = tpl.innerHTML;
                    if (!document.getElementById('card-wrapper')) content.innerHTML = tpl.innerHTML;

                    const activeCount = Object.values(this.state.activeDeckIds).filter(Boolean).length;
                    document.getElementById('deck-label').innerText = activeCount > 1 ? `Combined Deck (${activeCount})` : 'Single Deck';
                    
                    const currentCard = this.state.currentDeck[this.state.drawIndex];
                    if (currentCard) {
                        document.getElementById('card-counter').innerText = `Card ${this.state.drawIndex + 1} of ${this.state.currentDeck.length}`;
                        const anim = isReshuffle ? 'card-reshuffle-enter' : 'card-enter';
                        document.getElementById('card-wrapper').innerHTML = this.renderCardHTML(currentCard, anim);
                    } else {
                        document.getElementById('card-wrapper').innerHTML = '<div class="flex items-center justify-center h-full text-slate-400">Deck Empty</div>';
                    }
                    this.setupGestures();

                } else if (this.state.view === 'saved') {
                    const tpl = document.getElementById('tpl-saved');
                    content.innerHTML = tpl.innerHTML;
                    
                    if (this.state.keptCards.length === 0) {
                        document.getElementById('empty-state').classList.remove('hidden');
                        document.getElementById('saved-grid').classList.add('hidden');
                    } else {
                        const grid = document.getElementById('saved-grid');
                        grid.innerHTML = this.state.keptCards.map(card => {
                            const deckConf = this.getDeckConfig(card._deckId);
                            const suitConf = this.getSuitConfig(card.suit);
                            return `
                            <div class="bg-white rounded-xl p-4 shadow-sm border border-slate-200 flex items-start space-x-4 relative overflow-hidden">
                                <div class="absolute top-0 left-0 bg-slate-100 text-[8px] px-2 font-bold uppercase text-slate-400">${deckConf.name}</div>
                                <div class="text-4xl bg-slate-50 p-2 rounded-lg border border-slate-100 mt-2">${card.visual}</div>
                                <div class="mt-2">
                                    <h3 class="font-bold text-slate-800">${card.title}</h3>
                                    <p class="text-xs text-slate-500 uppercase tracking-wide mb-1">${card.concept}</p>
                                    <p class="text-sm text-slate-600 leading-snug">"${card.example}"</p>
                                    <button onclick="app.removeSaved('${card.id}')" class="text-xs text-red-400 hover:text-red-600 mt-2 flex items-center">Remove</button>
                                </div>
                            </div>`;
                        }).join('');
                    }

                } else if (this.state.view === 'gallery') {
                    const tpl = document.getElementById('tpl-gallery');
                    content.innerHTML = tpl.innerHTML;
                    const gallery = document.getElementById('gallery-content');
                    
                    // Create map of active cards
                    const cardMap = this.getCardMap();
                    let allActiveCards = [];
                    Object.keys(this.state.activeDeckIds).forEach(dId => {
                         if(this.state.activeDeckIds[dId]) {
                             allActiveCards = [...allActiveCards, ...Object.values(cardMap).filter(c => c._deckId === dId)];
                         }
                    });

                    // Order of suits from config
                    Object.keys(APP_CONFIG.suits).forEach(suitKey => {
                        const suitConf = APP_CONFIG.suits[suitKey];
                        const cards = allActiveCards.filter(c => c.suit === suitKey)
                            .sort((a,b) => {
                                const order = ['2','3','4','5','6','7','8','9','10','J','Q','K','A','‚òÖ'];
                                return order.indexOf(a.rank) - order.indexOf(b.rank);
                            });
                        
                        if (cards.length === 0) return;

                        const isRed = suitConf.color === 'red';
                        const colorClass = isRed ? 'text-red-600' : 'text-slate-700';
                        const iconColor = isRed ? 'text-red-500' : 'text-slate-700';

                        gallery.innerHTML += `
                        <div class="mb-10">
                            <div class="flex items-center space-x-2 border-b ${isRed ? 'border-red-200' : 'border-slate-200'} pb-2 mb-4">
                                <i data-lucide="${suitConf.icon}" class="${iconColor} w-4 h-4 fill-current"></i>
                                <h3 class="text-lg font-bold uppercase tracking-wider ${colorClass}">${suitConf.label}</h3>
                                <span class="text-xs text-slate-400 ml-auto font-mono bg-slate-100 px-2 py-0.5 rounded-full">${cards.length} Cards</span>
                            </div>
                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                                ${cards.map(c => {
                                    const isBurned = this.state.burnedCardIds.includes(c.id);
                                    const opacityClass = isBurned ? 'opacity-50 grayscale hover:grayscale-0 hover:opacity-100' : '';
                                    const burnedOverlay = isBurned ? `<div class="absolute inset-0 bg-slate-900/10 flex items-center justify-center z-20 pointer-events-none group-hover:hidden"><div class="bg-black/70 text-white text-[10px] uppercase font-bold px-2 py-1 rounded-full">Burned</div></div>` : '';
                                    const deckConf = this.getDeckConfig(c._deckId);
                                    
                                    return `
                                    <div onclick="${isBurned ? `app.restoreBurned('${c.id}')` : ''}" class="cursor-pointer ${opacityClass} bg-white rounded-lg p-3 shadow-sm border border-slate-200 hover:border-indigo-300 transition-all flex flex-col items-center text-center relative overflow-hidden group">
                                        ${burnedOverlay}
                                        <div class="absolute top-1 right-2 text-[8px] font-bold uppercase text-slate-300">${deckConf.name.split(' ')[0]}</div>
                                        <div class="text-2xl mb-1 z-10">${c.visual}</div>
                                        <div class="text-xs font-bold uppercase z-10 ${colorClass}">${c.rank}</div>
                                        <div class="font-bold text-slate-800 text-sm leading-tight mt-1 z-10">${c.title}</div>
                                        <div class="text-[10px] text-slate-500 mt-1 z-10 opacity-80 line-clamp-2">${c.concept}</div>
                                        <div class="absolute top-0 right-0 p-1 opacity-10 group-hover:opacity-20 ${iconColor}">
                                            <i data-lucide="${suitConf.icon}" class="w-10 h-10 fill-current"></i>
                                        </div>
                                    </div>`;
                                }).join('')}
                            </div>
                        </div>`;
                    });
                }
                
                lucide.createIcons();
            },

            setupGestures() {
                const wrapper = document.getElementById('card-wrapper');
                if(!wrapper) return;
                
                wrapper.addEventListener('touchstart', (e) => {
                    this.touchEnd = null;
                    this.touchStart = { x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY };
                });
                wrapper.addEventListener('touchmove', (e) => this.touchEnd = { x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY });
                wrapper.addEventListener('touchend', () => {
                    if (!this.touchStart || !this.touchEnd) return;
                    const dX = this.touchStart.x - this.touchEnd.x;
                    const dY = this.touchStart.y - this.touchEnd.y;
                    if (Math.abs(dX) > Math.abs(dY)) {
                        if (dX > 50) this.discard();
                        else if (dX < -50) this.keep();
                    } else {
                        if (dY < -50) this.reshuffle(true);
                    }
                });
            }
        };

        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>